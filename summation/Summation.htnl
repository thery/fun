import React, { useState, useEffect, useRef } from 'react';

const SierpinskiTriangle = () => {
  const canvasRef = useRef(null);
  const [isAnimating, setIsAnimating] = useState(false);
  const [depth, setDepth] = useState(10);
  const [summation, setSummation] = useState(0);
  const [step, setStep] = useState(0);
  const [isComplete, setIsComplete] = useState(false);
  const animationRef = useRef(null);

  const drawTriangle = (ctx, x1, y1, x2, y2, x3, y3, fill = true) => {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.closePath();
    
    if (fill) {
      ctx.fillStyle = '#3b82f6';
      ctx.fill();
    } else {
      ctx.fillStyle = 'white';
      ctx.fill();
    }
    
    ctx.strokeStyle = '#1e40af';
    ctx.lineWidth = 1;
    ctx.stroke();
  };

  const getMidpoint = (x1, y1, x2, y2) => {
    return [(x1 + x2) / 2, (y1 + y2) / 2];
  };

  const animateSierpinski = async (ctx, x1, y1, x2, y2, x3, y3, currentDepth, maxDepth, currentStep) => {
    if (currentDepth >= maxDepth) return currentStep;

    // Draw the filled triangle initially
    drawTriangle(ctx, x1, y1, x2, y2, x3, y3, true);
    
    await new Promise(resolve => setTimeout(resolve, 500));

    // Calculate midpoints
    const [mx1, my1] = getMidpoint(x1, y1, x2, y2);
    const [mx2, my2] = getMidpoint(x2, y2, x3, y3);
    const [mx3, my3] = getMidpoint(x3, y3, x1, y1);

    // Remove the center triangle (make it white)
    drawTriangle(ctx, mx1, my1, mx2, my2, mx3, my3, false);
    
    // Update summation
    currentStep++;
    const newSum = Array.from({length: currentStep}, (_, i) => Math.pow(1/4, i + 1)).reduce((a, b) => a + b, 0);
    setSummation(newSum);
    setStep(currentStep);
    
    await new Promise(resolve => setTimeout(resolve, 500));

    // Recursively animate only the top triangle
    return await animateSierpinski(ctx, x1, y1, mx1, my1, mx3, my3, currentDepth + 1, maxDepth, currentStep);
  };

  const startAnimation = async () => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // Clear canvas
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, width, height);

    // Reset summation
    setSummation(0);
    setStep(0);
    setIsComplete(false);

    setIsAnimating(true);

    // Define the initial equilateral triangle
    const size = 400;
    const x1 = width / 2;
    const y1 = 50;
    const x2 = x1 - size / 2;
    const y2 = y1 + (size * Math.sqrt(3)) / 2;
    const x3 = x1 + size / 2;
    const y3 = y2;

    await animateSierpinski(ctx, x1, y1, x2, y2, x3, y3, 0, depth, 0);
    
    setIsAnimating(false);
    setIsComplete(true);
  };

  const reset = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    setSummation(0);
    setStep(0);
    setIsComplete(false);
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-50 p-8">
      <div className="bg-white rounded-lg shadow-lg p-6">
        <h1 className="text-3xl font-bold text-gray-800 mb-4 text-center">
          Summation Triangle Animation
        </h1>
        
        <canvas
          ref={canvasRef}
          width={600}
          height={550}
          className="border-2 border-gray-300 rounded mb-4"
        />
        
        <div className="bg-blue-50 border-2 border-blue-300 rounded-lg p-4 mb-4">
          <h2 className="text-xl font-bold text-gray-800 mb-2">Summation</h2>
          <div className="text-lg font-mono">
            {step === 0 ? (
              <span className="text-gray-500">No triangles removed yet</span>
            ) : (
              <div>
                <div className="mb-2">
                  {Array.from({length: Math.min(step, 5)}, (_, i) => (
                    <span key={i}>
                      {i > 0 && ' + '}
                      (1/4)<sup>{i + 1}</sup>
                    </span>
                  ))}
                  {step > 5 && ' + ...'}
                </div>
                <div className="text-2xl font-bold text-blue-600">
                  = {summation.toFixed(8)}
                </div>
                {isComplete && (
                  <div className="mt-4 pt-4 border-t-2 border-blue-300">
                    <div className="text-lg text-gray-700 mb-2">
                      Therefore, as n → ∞:
                    </div>
                    <div className="text-xl font-bold text-green-600">
                      ∑<sub>i=1</sub><sup>∞</sup> (1/4)<sup>i</sup> = 1/3
                    </div>
                    <div className="text-sm text-gray-600 mt-2">
                      (Our approximation with 10 terms: {summation.toFixed(8)} ≈ {(1/3).toFixed(8)})
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
        
        <div className="flex flex-col gap-4">
          <div className="text-center text-gray-700 font-medium">
          </div>
          
          <div className="flex gap-4">
            <button
              onClick={startAnimation}
              disabled={isAnimating}
              className="flex-1 bg-blue-500 text-white px-6 py-3 rounded-lg font-semibold hover:bg-blue-600 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            >
              {isAnimating ? 'Animating...' : 'Start Animation'}
            </button>
            
            <button
              onClick={reset}
              disabled={isAnimating}
              className="flex-1 bg-gray-500 text-white px-6 py-3 rounded-lg font-semibold hover:bg-gray-600 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            >
              Reset
            </button>
          </div>
        </div>
        
        <p className="mt-4 text-sm text-gray-600 text-center">
          This animation creates a triangle by recursively subdividing triangles and removing the center piece.
        </p>
      </div>
    </div>
  );
};

export default SierpinskiTriangle;