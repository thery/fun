<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Triangle Summation Animation</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background-color: #f9fafb;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 1rem;
    }
    
    .container {
      background: white;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      padding: 1rem;
      max-width: 50rem;
      width: 100%;
    }
    
    h1 {
      font-size: 1.5rem;
      font-weight: bold;
      color: #1f2937;
      margin-bottom: 0.75rem;
      text-align: center;
    }
    
    #canvas-container {
      border: 2px solid #d1d5db;
      border-radius: 0.25rem;
      margin-bottom: 0.75rem;
      background: white;
      width: 100%;
      max-width: 700px;
      height: 400px;
      margin-left: auto;
      margin-right: auto;
    }
    
    .summation-box {
      background: #eff6ff;
      border: 2px solid #93c5fd;
      border-radius: 0.5rem;
      padding: 0.75rem;
      margin-bottom: 0.75rem;
      min-height: 180px;
    }
    
    .summation-box h2 {
      font-size: 1.125rem;
      font-weight: bold;
      color: #1f2937;
      margin-bottom: 0.5rem;
    }
    
    .summation-content {
      font-size: 1rem;
      font-family: monospace;
      min-height: 70px;
    }
    
    .placeholder {
      color: #6b7280;
    }
    
    .formula {
      margin-bottom: 0.5rem;
    }
    
    .result {
      font-size: 1.25rem;
      font-weight: bold;
      color: #2563eb;
    }
    
    .conclusion-box {
      min-height: 90px;
    }
    
    .conclusion {
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 2px solid #93c5fd;
    }
    
    .conclusion-text {
      font-size: 1rem;
      color: #374151;
      margin-bottom: 0.5rem;
    }
    
    .conclusion-formula {
      font-size: 1.125rem;
      font-weight: bold;
      color: #16a34a;
    }
    
    .conclusion-note {
      font-size: 0.875rem;
      color: #6b7280;
      margin-top: 0.5rem;
    }
    
    .button-container {
      display: flex;
      gap: 1rem;
    }
    
    button {
      flex: 1;
      background: #3b82f6;
      color: white;
      padding: 0.625rem 1.25rem;
      border-radius: 0.5rem;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    button:hover {
      background: #2563eb;
    }
    
    .description {
      margin-top: 1rem;
      font-size: 0.8rem;
      color: #6b7280;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>3D Triangle Summation Animation</h1>
    
    <div id="canvas-container"></div>
    
    <div class="summation-box">
      <h2>Summation</h2>
      <div class="summation-content" id="summation-content">
        <span class="placeholder">No triangles removed yet</span>
      </div>
      <div class="conclusion-box" id="conclusion-box"></div>
    </div>
    
    <div class="button-container">
      <button id="main-button" onclick="handleMainButton()">Start Animation</button>
    </div>
    
    <p class="description">
      This 3D animation shows how repeatedly removing the central triangle leads to the infinite series 
      ∑(1/4)<sup>i</sup> from i=1 to ∞ which equals exactly 1/3 of the original area.
    </p>
  </div>

  <script>
    let scene, camera, renderer, mainGroup;
    let isAnimating = false;
    let isPaused = false;
    let isComplete = false;
    let summation = 0;
    let step = 0;
    const depth = 10;
    const animationControl = { shouldStop: false, shouldPause: false };

    function init() {
      const container = document.getElementById('canvas-container');
      const width = container.offsetWidth;
      const height = container.offsetHeight;
      
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
      camera.position.set(0, 0, 11);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
      directionalLight.position.set(8, 10, 8);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const fillLight = new THREE.DirectionalLight(0x4a7ab5, 0.5);
      fillLight.position.set(-5, -3, 5);
      scene.add(fillLight);

      mainGroup = new THREE.Group();
      scene.add(mainGroup);

      const size = 10.5;
      const triHeight = size * Math.sqrt(3) / 2;
      const v1 = new THREE.Vector2(0, triHeight / 2);
      const v2 = new THREE.Vector2(-size / 2, -triHeight / 2);
      const v3 = new THREE.Vector2(size / 2, -triHeight / 2);
      
      const initialMesh = createTriangleMesh(v1, v2, v3);
      mainGroup.add(initialMesh);

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    function createTriangleMesh(v1, v2, v3) {
      const shape = new THREE.Shape();
      shape.moveTo(v1.x, v1.y);
      shape.lineTo(v2.x, v2.y);
      shape.lineTo(v3.x, v3.y);
      shape.lineTo(v1.x, v1.y);

      const extrudeSettings = {
        depth: 0.3,
        bevelEnabled: true,
        bevelThickness: 0.05,
        bevelSize: 0.05,
        bevelSegments: 3
      };

      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

      const material = new THREE.MeshStandardMaterial({
        color: 0x4A90E2,
        roughness: 0.3,
        metalness: 0.0,
        flatShading: false,
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      
      return mesh;
    }

    async function animateTriangle(parent, v1, v2, v3, currentDepth, maxDepth, currentStep) {
      if (currentDepth >= maxDepth || animationControl.shouldStop) return currentStep;

      while (animationControl.shouldPause && !animationControl.shouldStop) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      if (animationControl.shouldStop) return currentStep;

      const m1 = new THREE.Vector2((v1.x + v2.x) / 2, (v1.y + v2.y) / 2);
      const m2 = new THREE.Vector2((v2.x + v3.x) / 2, (v2.y + v3.y) / 2);
      const m3 = new THREE.Vector2((v3.x + v1.x) / 2, (v3.y + v1.y) / 2);

      await new Promise(resolve => setTimeout(resolve, 500));
      
      if (animationControl.shouldStop) return currentStep;

      if (parent.children.length > 0) {
        const oldMesh = parent.children[0];
        parent.remove(oldMesh);
        oldMesh.geometry.dispose();
        oldMesh.material.dispose();
      }

      const newGroup = new THREE.Group();
      
      const corner1 = createTriangleMesh(v1, m1, m3);
      const corner2 = createTriangleMesh(m1, v2, m2);
      const corner3 = createTriangleMesh(m3, m2, v3);
      
      newGroup.add(corner1);
      newGroup.add(corner2);
      newGroup.add(corner3);
      
      parent.add(newGroup);

      currentStep++;
      const newSum = Array.from({length: currentStep}, (_, i) => Math.pow(1/4, i + 1))
                         .reduce((a, b) => a + b, 0);
      summation = newSum;
      step = currentStep;
      updateUI();
      
      await new Promise(resolve => setTimeout(resolve, 500));
      
      if (animationControl.shouldStop) return currentStep;

      return await animateTriangle(newGroup, v1, m1, m3, currentDepth + 1, maxDepth, currentStep);
    }

    async function startAnimation() {
      if (!mainGroup) return;

      animationControl.shouldStop = false;
      animationControl.shouldPause = false;
      summation = 0;
      step = 0;
      isComplete = false;
      isAnimating = true;
      isPaused = false;
      updateUI();
      updateButton();

      const size = 10.5;
      const triHeight = size * Math.sqrt(3) / 2;
      const v1 = new THREE.Vector2(0, triHeight / 2);
      const v2 = new THREE.Vector2(-size / 2, -triHeight / 2);
      const v3 = new THREE.Vector2(size / 2, -triHeight / 2);

      await animateTriangle(mainGroup, v1, v2, v3, 0, depth, 0);
      
      if (!animationControl.shouldStop) {
        isComplete = true;
      }
      isAnimating = false;
      isPaused = false;
      updateUI();
      updateButton();
    }

    function handleMainButton() {
      if (isComplete) {
        reset();
      } else if (!isAnimating) {
        startAnimation();
      } else if (isPaused) {
        animationControl.shouldPause = false;
        isPaused = false;
        updateButton();
      } else {
        animationControl.shouldPause = true;
        isPaused = true;
        updateButton();
      }
    }

    function updateButton() {
      const button = document.getElementById('main-button');
      if (isComplete) {
        button.textContent = 'Reset';
      } else if (!isAnimating) {
        button.textContent = 'Start Animation';
      } else if (isPaused) {
        button.textContent = 'Resume';
      } else {
        button.textContent = 'Pause';
      }
    }

    function updateUI() {
      const content = document.getElementById('summation-content');
      const conclusionBox = document.getElementById('conclusion-box');
      
      if (step === 0) {
        content.innerHTML = '<span class="placeholder">No triangles removed yet</span>';
        conclusionBox.innerHTML = '';
      } else {
        let formulaHTML = '<div class="formula">';
        for (let i = 0; i < Math.min(step, 5); i++) {
          if (i > 0) formulaHTML += ' + ';
          formulaHTML += `(1/4)<sup>${i + 1}</sup>`;
        }
        if (step > 5) formulaHTML += ' + ...';
        formulaHTML += '</div>';
        formulaHTML += `<div class="result">= ${summation.toFixed(8)}</div>`;
        content.innerHTML = formulaHTML;
        
        if (isComplete) {
          conclusionBox.innerHTML = `
            <div class="conclusion">
              <div class="conclusion-text">Therefore, as n → ∞:</div>
              <div class="conclusion-formula">∑<sub>i=1</sub><sup>∞</sup> (1/4)<sup>i</sup> = 1/3</div>
              <div class="conclusion-note">(Approximation with ${step} terms: ${summation.toFixed(8)} ≈ 0.33333333)</div>
            </div>
          `;
        } else {
          conclusionBox.innerHTML = '';
        }
      }
    }

    function reset() {
      animationControl.shouldStop = true;
      animationControl.shouldPause = false;
      
      if (!mainGroup) return;

      function clearGroup(group) {
        while (group.children.length > 0) {
          const child = group.children[0];
          if (child.children && child.children.length > 0) {
            clearGroup(child);
          }
          group.remove(child);
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        }
      }
      
      clearGroup(mainGroup);
      
      const size = 10.5;
      const triHeight = size * Math.sqrt(3) / 2;
      const v1 = new THREE.Vector2(0, triHeight / 2);
      const v2 = new THREE.Vector2(-size / 2, -triHeight / 2);
      const v3 = new THREE.Vector2(size / 2, -triHeight / 2);
      
      const initialMesh = createTriangleMesh(v1, v2, v3);
      mainGroup.add(initialMesh);
      
      summation = 0;
      step = 0;
      isComplete = false;
      isAnimating = false;
      isPaused = false;
      updateUI();
      updateButton();
    }

    window.onload = init;
  </script>
</body>
</html>